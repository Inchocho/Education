클래스명 : Dice(클래스 메소드구현)
주사위를 굴렸습니다
나온 숫자는 ? 입니다.

인스턴스변수 : int num
		DiceTest(실행)
메소드명 : diceRoll()
프로젝트명 : DiceGame

void diceRoll(){
	syso("주사위를 굴렸습니다")
	(int)((Math.random()*6)+1)
}

void viewDiceNum(){
	syso("나온 숫자는 ?(this.num) 입니다");
}

홀짝

입력값 홀짝 프로그램

클래스 1
메인 1
출력
홀짝프로그램입니다

인터페이스 - 공용 컴포넌트나 유틸개발에 효율적임
Predator 인터페이스 대신 Animal 클래스에 getFood 메소드를 추가하고 Tiger, Lion 등에서 getFood 메소드를 오버라이딩한 후 
Zookeeper의 feed 메소드가 Predator 대신 Animal을 입력 자료형으로 사용해도 동일한 효과를 거둘 수 있다. 
하지만 상속(extends)은 자식 클래스가 부모 클래스의 메소드를 오버라이딩하지 않고 사용할 수 있기 때문에 해당 메소드를 반드시 구현해야 한다는 "강제성"을 갖지 못한다. 
상황에 맞게 상속을 사용할 것인지 인터페이스를 사용해야 할 지를 결정해야 겠지만 인터페이스는 인터페이스의 메소드를 반드시 구현(implements)해야 하는 "강제성"을 갖는다는 점이다.

=========================패키지(package)============================
반드시 하나의 패키지에 속해야한다. (이클립스의 경우 패키지를 만들지않으면 default패키지를 만들어준다 -> 앞으로 패키지명 유의미하게 사용할것)
패키지는 반드시 소문자로만 만들어야 한다.

패키지란
클래스의 묶음이다
서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로
관리할 수 있다

클래스의 실제 이름은 (full name) 패키지명을 포함한 것이다

같은 이름의 클래스일 지라도 서로 다른 패키지에 속하면 패키지명으로 구별이 가능하다

-하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다
-모든 클래스는 반드시 하나의 패키지에 속해야 한다
-패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다
-패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다

패키지 선언
package 패키지명;

패키지 선언문은 반드시 소스파일에서 첫 번째 문장이어야 한다

명명규칙
-클래스명과 쉽게 구분하기 위해서 소문자로 하는 것을 원칙으로 하고 있다
-의미가 달라지면 .으로 구분한다 (필수는 아님)

물리적(하드디스크 디렉토리 추가)으로 생성되고 논리적(이클립스에 패지키)으로 생성됨

논리적 영역(이클립스) -> 폴더
물리적 영역(하드디스크) -> 디렉토리

패키지 생성시 논리영역(이클립스) -> one(패키지 생성됨)
패키지 생성시 물리영역(하드디스크) -> src -> one(디렉토리 추가됨)

물리영역에서 one -> oneChange로 변경시 논리영역 이클립스에서는 패키지명이 one 그대로임 이를 변경하려면 이클립스에서 F5(새로고침)하면 된다
이클립스에서 oneChange.two로 패키지 생성시 
이클립스에서는 oneChange 바로 밑에 two 패키지가 생성된다.
물리영역 즉 디렉토리는 src -> oneChange(패키지) -> two(패키지속 패키지) 이렇게 생성된다.
이클립스에서 three 패키지 생성시 oneChange,two,three 로 보이고
물리영역 디렉토리는 src -> oneChange,three(같은 디렉토리에 생성) -> oneChange.two(하위디렉토리) 디렉토리 이렇게 생성된다. 

=======다형성==========
instanceof 		
어떤 객체가 특정 클래스의 객체인지를 조사할 때 사용되는 
자바의 내장 명령어이다. animal instanceof Tiger 는 
"animal 객체는 Tiger 클래스로 만들어진 객체인가?"를 묻는 조건문

========================================
접근제어자
public : 접근제한이 없음 - 다른 패키지에서도 접근 가능
protected : 같은 패키지 + 상속받은 클래스에서 접근 가능
(protected는 상속받은 개체를 자식클래스가 만들어서 자식클래스의 객체로 지정해서 사용)
default : 같은 패키지에서만 접근 가능
private : 클래스 내에서만 접근 가능

꼭 필요한 정보와 기능만 외부에 오픈하는 것
대부분의 멤버 변수와 메서드를 감추고 외부에 통합된 인터페이스만은 제공해 일관된 기능을 구현하게 하는 것
각각의 메서드나 멤버 변수를 접근함으로써 발생하는 오류를 최소화 할 수 있는 장점도 있다

접근제어자를 사용하는 이유
private와 public을 주로 보게될것

데이터를 보호하기 위해
사용하는데 불필요한 멤버를 숨기기 위해

====================================
getter & setter 예제
set단어			get단어
-값을 넣는다		-값을 반환한다
-대입을 한다		-가져온다
-셋팅을 한다		-내용을 본다


getter 사용규칙
1.반환형이 멤버 변수와 같은 형식이다
2.매개변수는 없다

int num;
Ex) int getNum(){
	return num;
}

setter 사용규칙
1.반환형은 void
2.멤버 변수와 동일한 형식의 매개변수가 있어야 함

int num;
Ex)void setNum(int num){
	this.num = num;
}

형태가 고정되있음 getter setter는(내부에 코드는 존재하지 않는다)
get부터 적고 set을 적는다 (무조건 get/set은 한쌍임)
get은 조회하기 위해서 사용, set은 매개변수를 통해 값을 담는다.

	private String name = "";
	
	public String getName() {	--> 접근제어자는 public 고정
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
앞으로 getter/setter 이클립스에서는
클래스의 변수만을 선언,초기화하고 getter/setter를 source -> generate getter/setter 선택시 자동으로 만들어진다.


