이클립스 단축키

ctrl + shift + r : 파일찾기(검색)
ctrl + h : 찾을 문구가 포함된 ~ 찾기,파일찾기(검색)

f3 : 선언된 곳으로 찾아간다 MyMath()에서 f3 누르면 MyMath 클래스로 이동됨
alt + <- : 이전 작업하던 파일로 이동
alt + -> : 앞으로 작업하던 파일로 이동

객체지향 프로그래밍 (Object oriented Programming)

객체지향 메소드의 종류

반환타입:void(반환값이 없다), 메서드이름:add, 타입변수명: (int x, int y, ,,,(필요한만큼))
void add(int x, int y){
	어쩌구 저쩌구
}

반환타입:int(return하는 값이 int타입), 메서드이름: add, 타입변수명 int x, int y(이걸 파라미터 매개변수라 한다)
int add(int x, int y){
	어쩌구 저쩌구
	return 뭐시기;
}

(1)입력과 리턴값이 모두 있는 메소드 (메소드의 자료형, 입력값(매개변수)자료형 선언)
(2)입력은 없고 리턴값이 있는 메소드 (메소드의 자료형 선언)
(3)입력은 있고 리턴값은 없는 메소드 (void 선언 - 리턴이 없음, 입력값 (매개변수) 자료형 선언)
(4)입력도 없고 리턴값도 없는 메소드 (void 선언 - 리턴이 없음)

void 메소드의 사용처 (리턴타입이 없는 메소드)
인게임내 환경설정, 더이상 활용이 필요없는 연산일 경우

리턴타입이 있는 메소드의 사용처
안에 내용을 좀더 활용할 필요가 있는 경우 사용, 활용, 출력, 확인


(1)입력과 리턴값이 모두 있는 메소드의 예시
int sum(int a, int b) {
    return a+b;
}
입력값 :(매개변수) int형 a,b
리턴값 :a+b;

Sample sample = new Sample();
int result = sample.sum(3, 4);

(2)입력은 없고 리턴값이 있는 메소드의 예시
String say() {
    return "Hi";
}
입력값 : 없음
리턴값 : "Hi" 문자열

Sample sample = new Sample();
String a = sample.say();
System.out.println(a);  // "Hi" 출력

(3)입력은 있고 리턴값은 없는 메소드 (void)
void sum(int a, int b) {
    System.out.println(a+"과 "+b+"의 합은 "+(a+b)+"입니다.");
}

Sample sample = new Sample();
sample.sum(3, 4); // 3과 4의 합은 7입니다 출력됨 (리턴값은 없고 바로 출력문)

입력값 : 매개변수 int형 a,b
리턴값 : 없음

(4)입력도 없고 리턴값도 없는 메소드
void say() {
    System.out.println("Hi");
}

Sample sample = new Sample();
sample.say();	// Hi 출력됨 

입력값 : 없음
리턴값 : 없음

//return의 쓰임새//
특별한 경우에 메소드를 빠져나가기를 원할 때 return을 단독으로 사용하여 메소드를 즉시 빠져나갈 수 있다.
void 함수에서 return; 이란 함수를 종료시키는 의미한다.

void sayNick(String nick) {
	if ("fool".equals(nick)) {
		return;
	}
	System.out.println("나의 별명은 "+nick+" 입니다.");
}

nick 이 fool일경우 메소드 종료를 위해 return을 선언 (while에서 break, switch에서 default의 역할과 비슷)

+++ void에는 묵시적으로 return 메소드가 실행되지만 표기되어 있지 않다.(메소드 종료를 위해서)
메소드에는 반드시 return문이 있어야한다.(void타입일경우 묵시적으로 처리되서 안보일뿐 실제로는 작동함)

-------
This의 역할
자기자신의 메모리를 가르키는 역할을 합니다.
생성자에서 다른 생성자를 호출 하는 역할을 합니다.
인스턴스가 자기 자신의 주소를 반환할 때 사용합니다.
자기 자신의 메모리를 가리키는 this

---------------------------------------------------------------------------------------------
객체생성 
---------------------------------------------------------------------------------------------
Tv.java(클래스파일 참조)

Tv tv = new Tv();

new 연산자를 통해 Tv라는 클래스타입인 
color,power,channel의 객체변수와
channelUp,Down,changeChannel() 메소드를 가진 객체(인스턴스)가 생성된다.
		
TvExamTest1.java 파일 참조
//		얕은 복사(shallow copy) 복제의 개념 copy 
//		객체가 참조하고 있는 객체의 주소만 복제
//		얕은 복사의 경우 주소 값을 복사하기 때문에, 참조하고 있는 실제값은 같다.
//		Tv tv3; (tv3는 클래스Tv타입임)
//		tv3 = tv1; (tv3 = tv1 원본 객체 tv1을 tv3에 복제한다.)
//		원본과 복제본이 같은 객체를 공유

변수의 경우 복제시 값이 달라지지만

x = n;
n = 10;

x = 10;
n = 10;

n = 10 + 5; -> 15
x = 10;     -> 10

객체의 경우 위처럼 복제시 객체가 참조하고 있는 객체의 주소를 복제하기 때문에
tv1.channel = tv3.channel; -> 만약 3이었다고 치고
tv1.channel = 7;  ----------> 이렇게 tv1의 채널만 바꿔줘도
tv1.channel == tv3.channel;-> 이렇게 tv1의 채널과 tv3의 채널은 같다.
참조변수(stack)에 있는 주소값은 (heap)에 있는 참조변수에 대응하는 값을 가져오는데 위경우 대응값을 바꿔도 같은 주소를 같기때문에 둘다 변경된다.

//객체를 복제하고 다른 행동을 하기 위해서는
TvTest4.java를 참조
복제하고 싶은 객체의 변수를 복사해서 사용하면 된다.

tv1.channel = 7;
//tv2 = tv (객체를 직접 복사하는게 아니라)
//아래처럼 인스턴스(객체)의 변수를 복사해온다.
tv2.channel = tv.channel;
tv2.power = tv.power;
tv2.color = tv.color;

//이경우 객체를 직접 복사해온게 아니므로 객체가 참조하고 있는 객체의 주소를 복사해오지 않았기 때문에 tv의 채널을 내려도 tv2에는 영향이 없다.
tv.channelDown();
System.out.println("현재 채널은 " + tv.channel + "번 입니다"); --> 6
System.out.println("현재 채널은 " + tv2.channel + "번 입니다"); --> 7

클래스 
: 데이터와 함수의 결합

변수 -> 배열 -> 구조체 -> 클래스

변수
:하나의 데이터를 저장 할 수 있는 공간
배열
:같은 종류의 여러 데이터를 하나의 집합으로 저장 할 수 있는 공간
구조체
:서로 연관된 여러 데이터를 종류에 관계없이 하나의
집합으로 저장 할 수 있는 공간
클래스
:데이터와 함수의 결합(구조체 + 함수)
---------------------------------------------------
인스턴스란?

설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.
실체화된 인스턴스는 메모리에 할당된다.
인스턴스는 어떤 원본(추상적인 개념)으로부터 ‘생성된 복제본’을 의미한다.
객체는 클래스의 인스턴스라 볼 수 있다.

클래스(Class) VS 객체(Object)
클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.

객체(Object) VS 인스턴스(Instance)
클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
객체는 ‘실체’, 인스턴스는 ‘관계’에 초점을 맞춘다.
객체를 ‘클래스의 인스턴스’라고도 부른다.

클래스변수,지역변수,인스턴스변수 구분

변수의 종류				선언위치					생성시기(메모리 할당 시기)
클래스변수(=스태틱변수)		클래스 영역					클래스가 메모리에 올라갈 때 (단한번) // 인스턴스변수앞에 static을 붙이면 클래스변수
인스턴스변수		   		클래스 영역					인스턴스가 생성될 때
지역변수	  클래스 이외의 영역(메서드,생성자,초기화 블럭)	변수 선언문이 수행 되었을때

1.인스턴스변수
클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.  -----> Tv tv = new Tv(); new 연산자를 통해 생성함
그렇기 때문에 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저
인스턴스를 생성해야 한다. 인스턴스는 독립적인 저장공간을 가지므로
서로 다른 값을 가질 수 있다.
인스턴스마다 고유한 상태를 유지해야하는 속성의 경우
인스턴스변수로 선언한다.

2.클래스변수
클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static을 붙이기만 하면 된다
인스턴스마다 독립적인 저장공간을 갖는 인스턴스변수와는 달리,
클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.
한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 속성의 경우
클래스변수로 선언해야 한다
클래스변수는 인스턴스변수와 달리 인스턴스를 생성하지 않고도 언제라도 바로
사용할 수 있다는 특징이 있으며, '클래스이름.클래스변수'와 같은 형식으로 사용한다.
클래스 변수의 경우 인스턴스.클래스변수로 사용 할 수 는 있지만 <<클래스명.클래스변수로 사용해야 한다.>>

3.지역변수
메서드 내에 선언되어 메서드 내에서만 사용 가능하며,
메서드가 종료되면 소멸되어 사용할 수 없게 된다.
for문 또는 while문의 블럭 내에 선언된 지역변수는
지역변수가 선언된 블럭{} 내에서만 사용가능하며,
블럭을 벗어나면 소멸되어 사용 할 수 없게 된다


public class Test {

	int iv; // 인스턴스 변수 instance variable
	static int cv; // 클래스 변수 (static) class variable
	
	void method() {
		int lv; // 지역 변수 local variable
	}
}

Test test = new Test();

인스턴스 test 에는 인스턴스변수 iv와 메소드 method()를 가지고 있다.

사칙연산 야매처리
	// 사칙연산 나누기 (실수부 3자리까지 출력인데 야매)
	void div2(double x, double y) {
		double result = x / y;

		System.out.println(x + " / " + y + " = " + result);
		//야매처리
		System.out.println(x + " / " + y + " = " + ((result + 0.01) * 100) / 100);

	}