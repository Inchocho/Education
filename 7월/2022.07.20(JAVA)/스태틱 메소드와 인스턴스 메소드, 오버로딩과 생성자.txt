스태틱 메서드와 인스턴스 메서드

1.클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로
사용해야하는 것에 static을 붙인다
-생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수(iv)는
서로 다른 값을 유지한다 그러나 모든 인스턴스에서 같은 값이 유지되어야
하는 변수는 static을 붙여서 스태틱 변수로 정의한다

2.스태틱 변수는 인스턴스를 생성하지 않아도 사용할 수 있다
-static이 붙은 변수는 클래스가 메모리에 올라갈 때 이미
자동적으로 생성되기 때문이다
static이라는 키워드를 붙여서 선언된 필드와 메소드인 '클래스 멤버'도 static 영역에 올라갑니다. 
static 영역에 있는 것은 어떤 곳에서나 접근이 가능해지기 떄문에 '전역'이라는 키워드를 사용합니다.



3.스태틱 변수(스태틱 메서드)는 인스턴스 변수를 사용 할 수 없다		
-인스턴스변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데
스태틱 메서드는 인스턴스 생성 없이 호출가능하므로 스태틱 메서드가 
호출되었을 때 인스턴스가 존재하지 않을 수도 있다
그래서 클래스 메서드에서 인스턴스변수의 사용을 금지한다
반면에 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을
사용하는 것이 언제나 가능하다
인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는
것을 의미하기 때문이다

참고: static을 붙여야 할때?
절대적인 느낌의 것들

스태틱변수,메소드( == 전역변수,클래스변수)는 클래스를 생성하면서 최우선적으로 바로 만들어지기 때문에 
어디서든 사용 할 수 있다.


#################################################

인스턴스변수,메소드 ---> 스태틱변수,메소드 이용가능
스태틱변수,메소드 ---> 인스턴스변수,메소드 이용 불가능 ( 스태틱시점에서 인스턴스는 없음 )

new Tv().power = true; // -- 여기서 강제로 true값을 넣어줘도 이 객체에서의 power값만 true이고 찾을 수 없다 (사용하면 안되는 코드형식)
System.out.println(new Tv().power); // -- false

즉 위에 코드와 아래코드가 수행되는 객체는 서로 다른 객체이므로 결과값이 다르게 나온것이다.

new연산자를 통해서 객체 생성시 새로운 객체를 생성하게 된다.
인스턴스변수의 default값인 false가 나온다.

오버로딩
오버로딩의 조건
1.메서드 이름이 같아야 한다
2.매개변수의 개수 또는 타입이 달라야 한다

오버로딩의 장점
1.메서드의 이름만 보고도 같은 기능을 하겠구나 쉽게 예측이 가능 
2.메서드의 이름을 절약
3.동일한 메서드를 사용할경우 알아서 파라미터의 타입을 확인해서 선택해서 메서드를 수행하게된다.

오버로딩의 예시
println() F3을통해 메소드로 이동해보면 println메소드 또한 매개변수의 타입을 변경하여 오버로딩을 사용한것을 확인가능하다.

    public void println() {
        newLine();
    }
	
    public void println(boolean x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }
	
    public void println(String x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }	
	
    public void println(char x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }	
	
    public void println(int x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }	
	
System.out.println();
System.out.println(1);
System.out.println("설마");
System.out.println(true);

생성자
생성자 활용은 오버로딩을 통해서 (메소드의 매개변수 타입을 다르게하거나 매개변수의 개수를 다르게하거나 하는등)


	생성자(Constructor)
	
	생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드' 이다
	
	생성자의 조건
	1. 생성자의 이름은 클래스의 이름과 같아야 한다
	2. 생성자는 리턴 값이 없다
	
	클래스이름(타입 변수명, 타입 변수명, ,,,) {
		인스턴스 생성 시 수행될 코드
		주로 인스턴스 변수의 초기화 코드를 적는다
	}
	
	ex:
	Card(String k, int num);
	1.연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다
	2.생성자 Card()가 호출되어 수행된다
	3.연산자 new의 결과로 생성된 Card인스턴스의 주소가 반환되어 참조변수에 저장된다


	기본 생성자(default constructor)
	모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다
	생성자를 정의하지 않은경우 자바컴파일러가 기본 생성자를 생성해준다
	기본 생성자는 매개변수가 없는 형태다

	클래스이름() {
		
	}
	
	생성자를 명시할경우 기본생성자는 생성되지않는다

	지금까지 생성자가 없어도 오류가 안났던이유?
	자바 컴파일러가 기본 생성자(default constructor)라는 것을 기본적으로 제공해 주기 때문

	Constructor(){
		
	}
	
	(메인메소드 실행 파일) CarTest2.java
	Car2 car = new Car2(); //생성자 명시 안한경우 기본생성자를 자바컴파일러가 생성하므로 에러가 안났던것이다. 
	Car2 car2 = new Car2(5);	
	Car2 car3 = new Car2("문자");
	
	(클래스파일) Car2.java
	Car2(){
		System.out.println("아하 이 순간에 생성자가 수행되는 구나");
	}
	
	Car2(int d){
		System.out.println("내 매개변수는 정수형이야 - 오버로딩의 예시");
	}
	
	Car2(String d){
		System.out.println("내 매개변수는 문자열이야 - 오버로딩의 예시");
	}		
	
this의 사용법
this란?
생성자의 이름으로 ###클래스이름 대신 this를 사용한다###
this는 그 인스턴스의 주소이다
동일한 클래스 내의 다른 생성자에서 하나의 생성자를 호출하려면this 키워드를 사용
this 키워드를 사용하는 표현식은 생성자의 첫 번째 행이어야한다.		

형식
this --> 객체 자신, 파라미터 값으로 객체 자신의 참조값(메모리주소) 넘겨줄때 this를 사용
this.멤버변수(인스턴스변수나 클래스변수) --> 매개변수와 객체 자신이 가지고있는 변수(멤버변수)의 이름이 같은경우 이를 구분하기 위해 자신의 멤버변수에 this를 사용
this.매개변수 --> 생성자내에서 다른 생성자를 호출, this() 메소드에 매개변수를 전달하면, 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해준다.

생성자(매개변수로 유동적으로 유저의 요구에 따라 인스턴스변수 값을 초기화해줌)	
앞으로는 이와같이 매개변수와 인스턴스변수를 무조건 똑같이 짓게된다.
이걸 가능케 하는게 this키워드이다.	
Car(String color, String gearType, int door){
	
	this.color = color;
	this.gearType = gearType;
	this.door = door;
}
 